#/bin/bash

echo "pkgdir: ${PKGDIR}"

export LC_ALL=C

CYAN='\033[1;36m'
WHITE='\033[1;37m'
RED='\033[1;31m'
RESET='\033[0m'

debug() {
    [[ -z "$DEBUG" ]] && return

    echo -e "${CYAN}[DEBUG]${WHITE}: $@${RESET}"
}

error() {
    echo -e "${RED}[ERROR]${WHITE}: $@${RESET}"
}

trap "interrupt" 1 2 3 15
interrupt() {
    error "user interrupt detected"
    cleanup
    exit 10
}

cleanup() {
    [[ -z "$SKIPCLEANUP" ]] && {
        debug "clearing cache"
        rm -rf $TEMPDIR
    }
}

abort() {
    error "aborting: $2"
    [[ -z "${3}" ]] || {
        debug "${3}"
    }
    cleanup
    exit $1
}

TEMPDIR=$(mktemp -d /tmp/rcp.XXXXXXXXXX)
RCPSPEC=${RCPSPEC:-"/etc/rcp.spec"}
SRCDIR=${SRCDIR:-'/var/cache/src'}
PKGDIR=${PKGDIR:-'/var/cache/pkgs'}
COMPRESS_ALGO=${COMPRESS_ALGO:-'zstd'}

HEREDIR=$(pwd)

RECIPEFILEID=${1:-"$PWD/recipe"}

[[ -e "${RCPSPEC}" ]] && . "${RCPSPEC}"

export CFLAGS=${CFLAGS:-"-O2 -march=x86-64 -pipe"}
export CXXFLAGS=${CXXFLAGS:-$CFLAGS}
export MAKEFLAGS=${MAKEFLAGS:-"-j $(nproc)"}

[[ ! -f ${RECIPEFILEID} ]] && {
    abort 5 "no recipe file in current directory" "Must be at $(pwd)/recipe"
}

. ${RECIPEFILEID}


[[ -d $SRCDIR ]] || mkdir -p $SRCDIR
[[ -d $PKGDIR ]] || mkdir -p $PKGDIR

debug "downloading source file"
for s in ${source[@]} ; do
    if echo $s | grep -Eq '::(http|https|ftp)://' ; then
        filename=$(echo $s | awk -F '::' '{print $1}')
        url=$(echo $s | awk -F '::' '{print $2}')
    else
        filename="$(basename $s)"
        url="${s}"
    fi

    if [[ "${filename}" != "${s}" ]] ; then
        if [[ ! -e "${SRCDIR}/${filename}" ]] ; then
            wget -c --passive-ftp --no-directories --tries=3 --waitretry=3 --output-document="${SRCDIR}/${filename}.part" "${url}" ${WGET_ARGS}
        if [[ $? != 0 ]] ; then
            abort 7 "failed to download ${filename} from ${url}"
        fi
        mv ${SRCDIR}/${filename}{.part,}
        fi
    fi
done

debug "preparing source file"
WORKDIR=${TEMPDIR}/work
PKGDEST=${PKGDEST:-${TEMPDIR}/${name}}

[[ -d ${WORKDIR} ]] || mkdir -p $WORKDIR
[[ -d ${PKGDEST} ]] || mkdir -p $PKGDEST

for s in ${source[@]} ; do
    if echo $s | grep -Eq '::(http|https|ftp)://' ; then
        filename=${SRCDIR}/$(echo $s | awk -F '::' '{print $1}')
    elif echo $s | grep -Eq '^(http|https|ftp)://' ; then
        filename=${SRCDIR}/$(basename $s)
    else
        filename=${PWD}/$(basename $s)
    fi

    for noext in ${noextract} ; do
        if [[ "$noext" = "$(basename ${filename})" ]] ; then
            nxt=1
            break
        fi
    done

    [[ ! -f "${filename}" ]] && {
        abort 8 "${filename} is missing"
    }

    if [[ "${filename}" != "${file}" ]] && [[ "${nxt}" != 1 ]] ; then
        case "${filename}" in
            *.tar|*.tar.*|*.tgz|*.tbz2|*.txz|*.zip|*.rpm)
                case "${filename}" in
                    *bz2|*bzip2)
                        CMS=j
                        ;;
                    
                    *gz)
                        CMS=z
                        ;;

                    *xz)
                        CMS=J
                        ;;
                esac
                debug "extracting $(basename $filename)"
                tar -C "${WORKDIR}" -${CMS} -xf "${filename}"
                ;;
            
            *)
                debug "copying $(basename $filename)"
                cp "${filename}" "${WORKDIR}"
                ;;
        esac
        if [[ "$?" != 0 ]] ; then
            abort 8 "error while preparing file"
        fi
    else
        debug "copying $(basename $filename)"
        cp "${filename}" "${WORKDIR}"
        if [[ "$?" != 0 ]] ; then
            abort 9 "error while preparing file"
        fi
    fi

done

export src=${WORKDIR}
export pkg=${PKGDEST}

cd $src
(set -e -x; build 2>&1)
if [[ $? != 0 ]] ; then
    abort 2 "failed to compile package"
fi

if [[ ! -z "$splits" ]] ; then
    for sbuild in ${splits[@]} ; do
        export pkg="${PKGDEST}/$sbuild"
        (set -e -x; "build_$sbuild" 2>&1)
        if [[ $? != 0 ]] ; then
            abort 10 "error while compiling split package $sbuild"
        fi
        unset pkg
    done
fi

cd ${PKGDEST}
if [[ -z "$skip_strip" ]] ; then
if [[ "$nostrip" ]] ; then
    for i in ${nostrip[@]} ; do
        xstrip="$xstrip -e $i"
    done
    FILTER="grep -v $xstrip"
else
    FILTER="cat"
fi
fi

find . -type f -printf "%P\n" 2>/dev/null | $FILTER | while read -r binary ; do
    case "$(file -bi "$binary")" in
        *application/x-sharedlib*)  # Libraries (.so)
            ${CROSS_COMPILE}strip --strip-unneeded "$binary" 2>/dev/null ;;
        *application/x-pie-executable*)  # Libraries (.so)
            ${CROSS_COMPILE}strip --strip-unneeded "$binary" 2>/dev/null ;;
        *application/x-archive*)    # Libraries (.a)
            ${CROSS_COMPILE}strip --strip-debug "$binary" 2>/dev/null ;;
        *application/x-object*)
            case "$binary" in
                *.ko)                   # Kernel module
                    ${CROSS_COMPILE}strip --strip-unneeded "$binary" 2>/dev/null ;;
                *)
                    continue;;
            esac;;
        *application/x-executable*) # Binaries
            ${CROSS_COMPILE}strip --strip-all "$binary" 2>/dev/null ;;
        *)
            continue ;;
    esac
done

find . -type f -path "*/man/man*/*" | while read -r file; do
    if [ "$file" = "${file%%.gz}" ]; then
        gzip -9 -f "$file"
    fi
done

find . -type l -path "*/man/man*/*" | while read -r file; do
    FILE="${file%%.gz}.gz"
    TARGET="$(readlink $file)"
    TARGET="${TARGET##*/}"
    TARGET="${TARGET%%.gz}.gz"
    DIR=$(dirname "$FILE")
    rm -f $file
    if [ -e "$DIR/$TARGET" ]; then
        ln -sf $TARGET $FILE
    fi
done
if [ -d usr/share/info ]; then
    (cd usr/share/info
        for file in $(find . -type f); do
            if [ "$file" = "${file%%.gz}" ]; then
                gzip -9 "$file"
            fi
        done
    )
fi

if [[ "${REMOVE_DOCS}" ]] ; then
    debug "removing doc file"
    for i in doc gtk-doc info ; do
        rm -rf usr/share/${i} usr/${i} usr/local/${i} opt/share/${i}
    done
fi

cleanup
exit 0
